var documenterSearchIndex = {"docs":
[{"location":"library/problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"library/problem/","page":"Problem","title":"Problem","text":"Modules = [El0ps]\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/problem/#El0ps.Problem","page":"Problem","title":"El0ps.Problem","text":"Problem\n\nL0-penalized problem min f(mathbfAx) + lambda(mathbfx_0 + h(mathbfx)).\n\n\n\n\n\n","category":"type"},{"location":"library/problem/#El0ps.compute_λmax-Tuple{AbstractDatafit, AbstractPerturbation, Matrix}","page":"Problem","title":"El0ps.compute_λmax","text":"compute_λmax(\n    f::AbstractDatafit, \n    h::AbstractPerturbation, \n    A::Matrix, \n    y::Vector\n)\n\nReturn a value of λ such that 0 is a solution of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector, Ax::Vector)\n\nValue of the objective of a Problem when Ax is already computed.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector)\n\nValue of the objective of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"manual/path/#Regularization-path","page":"Fitting paths","title":"Regularization path","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"In this section, we consider some Problem data for which we want to fit a regularization path, i.e., solving the problem for a range of λ values.","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"using El0ps\nusing Random\n\nRandom.seed!(42)\n\nf = LeastSquares()\nh = Bigm(1.)\nA = randn(10, 30)\ny = randn(10)\n\nsolver = BnbSolver()","category":"page"},{"location":"manual/path/#Fitting-the-path","page":"Fitting paths","title":"Fitting the path","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"The path if fitted using the fit_path function as follows:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"path = fit_path(solver, f, h, A, y, verbosity=false)\nprintln(path)","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"This operation returns a Path instance with several information:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"λ/λmax: the ratio between the current λ and the value λmax above which the solution to the problem is necessarily the all-zero vector\nConv: whether the solver has converged\nTime: solution time\nFval: value of f(mathbfymathbfAx)\nhval: value of g(mathbfx) = mathbfx_0 + h(mathbfx)\nNnz: number of non-zeros in the solution\nCV mean: mean cross validation error on the term f(mathbfymathbfAx)\nCV std: standard deviation of the cross validation error on the term f(mathbfymathbfAx)","category":"page"},{"location":"manual/path/#Specifying-parameters","page":"Fitting paths","title":"Specifying parameters","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"When fitting the path, the following parameters can be specified:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"λratio_max: the maximum value of λ/λmax\nλratio_min: the minimum value of λ/λmax\nλratio_num: the number of λ values in the path\nmax_support_size: when a solution x is obtained in the path with norm(x,0) > max_support_size, the fitting is stopped\nstop_if_unsolved: stop the fitting when the problem at some λ has not been solved\ncompute_cv: whether to compute the cross validation error\nnb_folds: number of folds in the cross validation evaluation\nverbosity: toggle displays during the fitting","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"They are passed to the fit_path function as keyword arguments.","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"path = fit_path(solver, f, h, A, y, max_support_size=5, compute_cv=false)","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"More information is given in the documentation of the PathOptions struct which handle the path parameters.","category":"page"},{"location":"manual/quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"manual/quickstart/#Installation","page":"Quick start","title":"Installation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"El0ps.jl can be installed through Julia's Pkg manager as","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> add \"https://github.com/TheoGuyard/El0ps.jl\"","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To make sure that everything went properly, you can run","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> test El0ps","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The package can then be loaded with ","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using El0ps","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"note: Note\nEl0ps.jl is tested against Julia 1.7 and 1.8.","category":"page"},{"location":"manual/quickstart/#Problem-instantiation","page":"Quick start","title":"Problem instantiation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The different components of problems addressed by El0ps.jl are the loss function f, the perturbation term h, the matrix mathbfA, the vector mathbfy and the hyperparameter lambda. Here is an example on how a Problem can be instantiated.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using Random\nRandom.seed!(42)\n\n# Define problem data\nf = LeastSquares()\nh = Bigm(1.)\nA = randn(10, 30)\ny = randn(10)\nλ = 0.1\n\n# Problem instantiation\nproblem = Problem(f, h, A, y, λ)\n\n# Problem display\nprintln(problem)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The functions f and h are defined via structures provided by our package.  The function f must derive from the AbstractDatafit one and the function h must derive from the AbstractPerturbation one. Moreover, A and y must be a matrix and a vector with dimensions (m,n) and (m,), respectively. The columns of A needs not to be normalized but all-zero columns are not allowed. These latter can be removed without modifying the problem solution. Finally, the parameter λ must be strictly positive.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"When displaying a Problem, λmax corresponds to the value of λ above which the solution is always the all-zero vector. However, setting λ < λmax does not necessarily ensure to obtain a solution with some non-zero elements. The value of λmax can be computed from the problem data as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"λmax = compute_λmax(f, h, A, y)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The objective value of a Problem can be evaluated at any point x using","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x = rand(30)\nv = objective(problem, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the value of Ax is already known, this evaluation can also be done with","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"w = A * x\nv = objective(problem, x, w)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"in order to avoid re-evaluating the product Ax and to save computations.","category":"page"},{"location":"manual/custom/#Loss-and-perturbation-functions","page":"Custom functions","title":"Loss and perturbation functions","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"El0ps.jl is designed to be flexible regarding the choice of the functions f and h. It provides a simple way to define them.","category":"page"},{"location":"manual/custom/#Functions-already-supported","page":"Custom functions","title":"Functions already supported","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The following functions f and h are already supported by the package:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Loss / Perturbation Expression Parameters\nLeast-Squares f(mathbfy mathbfAmathbfx) = tfrac12mathbfy - mathbfAmathbfx_2^2 None\nLogistic f(mathbfy mathbfAmathbfx) = mathbf1^toplog(mathbf1 + exp(-mathbfyodotmathbfAmathbfx)) None\nBig-M h(mathbfx) = mathbbI(mathbfx_infty leq M) M  0\nBig-M + ell_1-norm h(mathbfx) = mathbbI(mathbfx_infty leq M) + alphamathbfx_1 Malpha  0\nBig-M + ell_2-norm h(mathbfx) = mathbbI(mathbfx_infty leq M) + betamathbfx_2^2 Mbeta  0\nell_1-norm h(mathbfx) = alphamathbfx_1 alpha  0\nell_2-norm h(mathbfx) = betamathbfx_2^2 beta  0\nell_1ell_2-norm h(mathbfx) = alphamathbfx_1 + betamathbfx_2^2 alphabeta  0","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"In the above table, the function mathbbI(mathcalC) denotes the convex indicator of the constraint mathcalC. The functions f and h can be instantiated as follows:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"f = LeastSquares()\nf = Logistic()\nh = Bigm(M)\nh = BigmL1norm(M, α)\nh = BigmL2norm(M, β)\nh = L1norm(α)\nh = L2norm(β)\nh = L1L2norm(α, β)","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"They all derive from the AbstractDatafit and AbstractPerturbation structs.","category":"page"},{"location":"manual/custom/#Defining-new-loss-functions","page":"Custom functions","title":"Defining new loss functions","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The function f must verify the following hypotheses:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"f\nis convex, proper and lower-semicontinuous\nf\nis differentiable\nnabla f\nis L-Lipschitz","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"If this is fulfilled, then a new loss function can be defined as follow.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"struct MyNewF <: AbstractDatafit end","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"For instance, the user can specify how it is pretty-printed with","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Base.show(io::IO, f::MyNewF) = print(io, \"MyNewF\")","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"So that the BnB solver can run, it is also require to define the following functions:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"lipschitz_constant(f::MyNewF, y::Vector) : returns the value of the Lipschitz constant L as a Float64 \nvalue(f::MyNewF, y::Vector, w::Vector) : returns the value of f(mathbfymathbfw) as a Float64 \ngradient(f::MyNewF, y::Vector, w::Vector) : returns the value of nabla f(mathbfymathbfw) as a Float64 \nconjugate(f::MyNewF, y::Vector, w::Vector) : returns the value of f^star(mathbfymathbfw) as a Float64, where f^star(mathbfycdot) denotes the convex conjugate of f(mathbfycdot)\ndual_scale!(f::MyNewF, y::Vector, w::Vector) : in-place transforms any vector w into a new vector belonging to the domain of f^star(mathbfycdot). No transformation is performed if the domain of f^star(mathbfycdot) is the whole space.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Then, the BnB is able to handle losses that are instances of MyNewF on his own.","category":"page"},{"location":"manual/custom/#Defining-new-perturbation-terms","page":"Custom functions","title":"Defining new perturbation terms","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The function h must verify the following hypotheses:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"h\nsplits, i.e., h(mathbfx) = sum_i h_i(x_i)\nThe splitting terms are proper, convex and lower-semicontinuous\nThe splitting terms are equals, i.e., h_i=h_j for all i neq j\nThe splitting terms are even\nThe splitting terms are coercive\nThe splitting terms verify h_i(x_i) geq h_i(0) = 0, for all i","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The above hypotheses are for instance verifies for norms, bound constraints, ... If they are fulfilled, then a new perturbation term can be defined as follow.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"struct MyNewH <: AbstractPerturbation end","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"For instance, the user can specify how it is pretty-printed with","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Base.show(io::IO, H::MyNewH) = print(io, \"MyNewH\")","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"So that the BnB solver can run, it is also require to define the following functions:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"value_1d(h::MyNewH, x::Float64): returns the value of h_i(x_i) as a Float64 \nconjugate_1d(h::MyNewH, x::Float64): returns the value of the confjugate function h_i^star(x_i) as a Float64 \nprox_1d(h::MyNewH, x::Float64, η::Float64): returns the proximity operator mathrmprox_eta h_i(cdot)(x) as a Float64\ndual_scale!(h::MyNewH, A::Matrix, u::Vector, λ::Float64): in-place transforms any vector u into a new vector belonging to the domain of f^star(mathbfytfrac1lambdamathbfA^topcdot). Returns the value of mathbfA^topmathbfu","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Then, the BnB is able to handle losses that are instances of MyNewH on his own.","category":"page"},{"location":"manual/custom/#Examples","page":"Custom functions","title":"Examples","text":"","category":"section"},{"location":"manual/custom/#Loss-function","page":"Custom functions","title":"Loss function","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The following portion of code shows how to implement a quadratic loss function f(mathbfymathbfw) = tfrac12mathbfw^topmathbfQmathbfw + mathbfw^topmathbfy. In this case, one has","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"L = sigma_max (mathbfQ)\n, where sigma_max(cdot) is the largest singular of some matrix.\nnabla f(mathbfymathbfw) = mathbfQw + y\nf^star(mathbfymathbfw) = mathbfQ^-1mathbf(w - y)","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"and the domain of f^star is the whole space.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"# Definition of the new struct \nstruct QuadraticLoss <: AbstractDatafit \n    Q::Matrix\n    QuadraticLoss(Q::Matrix) = new(Q)\nend\n\n# Definition of the loss operators\nlipschitz_constant(f::QuadraticLoss, y::Vector) = maximum(svdvals(f.Q))\nvalue(f::QuadraticLoss, y::Vector, w::Vector) = 0.5 * (w' * f.Q * w) + w' * y\ngradient(f::QuadraticLoss, y::Vector, w::Vector) = f.Q * w + y\nconjugate(f::QuadraticLoss, y::Vector, w::Vector) = inv(Q) * (w - y)\ndual_scale!(f::QuadraticLoss, y::Vector, w::Vector) = nothing","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Note that computations can be easily casev by computing and storing the value of L and mathbfQ^-1 once for all when initializing the QuadraticLoss struct.","category":"page"},{"location":"manual/custom/#Perturbation-term","page":"Custom functions","title":"Perturbation term","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The following portion of code shows how to implement a p-norm perturbation term h(mathbfx) = sum_ih_i(x_i)  with h_i(x_i) = tfrac1px_i^p for all i. In this case, one has","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"h_i^star(u) = tfrac1qu^q\nmathrmprox_eta h_i(cdot)(x) = mathrmsign(x) times mathrmroot(eta r^p-1+r-x)","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"where q is such that tfrac1p + tfrac1q = 1 and where mathrmroot(P(r)) returns a root of the polynomial P(r).","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"# For the prox operation\nusing Roots\n\n# Definition of the new struct \nstruct LpNorm <: AbstractPerturbation\n    p::Int\n    q::Int\n    LpNorm(p::Int) = new(p, p/(p-1))\nend\n\n# Definition of the loss operators\nvalue_1d(h::LpNorm, x::Float64) = abs(x)^(h.p) / h.p\nconjugate_1d(h::LpNorm, x::Float64) = abs(x)^(h.q) / h.q\nprox_1d(h::LpNorm, x::Float64, η::Float64) = sign(x) * find_zero(r -> ηr^(h.p-1) + r - abs(x), 0) \ndual_scale!(h::MyNewH, A::Matrix, u::Vector, λ::Float64) = A' * u","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Above, the Roots package is used in the prox_1d to solve the polynomial equation.","category":"page"},{"location":"library/penalties/#Penalties","page":"Penalties","title":"Penalties","text":"","category":"section"},{"location":"library/penalties/","page":"Penalties","title":"Penalties","text":"Modules = [El0ps]\nPages   = [\n    \"penalties/core.jl\",\n    \"penalties/bigm.jl\",\n    \"penalties/bigml1norm.jl\",\n    \"penalties/bigml2norm.jl\",\n    \"penalties/l1norm.jl\",\n    \"penalties/l2norm.jl\",\n    \"penalties/l1l2norm.jl\",\n]","category":"page"},{"location":"library/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"library/solvers/","page":"Solvers","title":"Solvers","text":"Modules = [El0ps]\nPages   = [\n    \"solvers/core.jl\",\n    \"solvers/bnb.jl\",\n]","category":"page"},{"location":"manual/optimize/#Solving-problems","page":"Solving problems","title":"Solving problems","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"In this section, we consider a Problem instance that is to be solved.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"using El0ps\nusing Random\n\nRandom.seed!(42)\n\nf = LeastSquares()\nh = Bigm(1.)\nA = randn(10, 30)\ny = randn(10)\nλ = 0.1\n\nproblem = Problem(f, h, A, y, λ)","category":"page"},{"location":"manual/optimize/#Running-the-solver","page":"Solving problems","title":"Running the solver","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The problem can be addressed with the BnbSolver, instantiated with ","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"solver = BnbSolver()","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Here, we do not specify any argument, so the default ones are used. Then, simply call the optimize function to solve the problem.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result = optimize(solver, problem)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The result specifies different statistics about the solution process:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The solution status\nOPTIMAL when convergence is met \nTIME_LIMIT when the maximum time allowed is reached\nITERATION_LIMIT when the maximum number of nodes allowed is reached\nThe best objective value obtained\nThe number of non-zero elements in the solution\nThe last MIP gap, which should be zero at optimality\nThe overall solution time\nThe number of BnB nodes processed","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The solution of the problem can be accessed via","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result.x","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"warning: Warning\nWhen the solution status is not OPTIMAL, then the objective value may not correspond to the optimal value of the problem and the solution returned may not be the optimal one.","category":"page"},{"location":"manual/optimize/#Specifying-parameters","page":"Solving problems","title":"Specifying parameters","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"When creating a BnbSolver, different parameters can be specified. First, there exists parameters to control and limit the execution of the solver:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"exploration : the BnB exploration strategy (BFS or DFS)\nbranching : the BnB branching strategy (LARGEST or RESIDUAL)\nmaxtime : the maximum solution time allowed (in seconds)\nmaxnode : the maximum number of nodes \ntolgap : the targeted MIP duality gap in the BnB\ntolint : the integrality tolerance in the BnB\ntolprune : the tolerance when testing if a node is pruned","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Moreover, the use can toggle different acceleration strategies using the boolean parameters.  All these acceleration do not impact the correctness of the BnB process.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"dualpruning : allows to detect prunable nodes early\nl0screening : enable the node-screening methodology to avoid uninteresting nodes in the BnB\nl1screening : enable the screening methodology to accelerate the node bounding process","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Finally, the BnB displays and logs can also be controlled via:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"verbosity : toggle displays while solving the problem\nshowevery : difference in nodes between two consecutive displays\nkeeptrace : return a trace of the exploration in the result","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"They can be passed to the solver as keywords arguments:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"solver = BnbSolver(maxtime=60., verbosity=false)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"More information is given in the documentation of the BnbOptions structure that collects the keywords passed to BnbSolver.","category":"page"},{"location":"manual/optimize/#Warm-start","page":"Solving problems","title":"Warm start","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"When calling optimize, a warm start can be specified as follows:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"x0 = rand(30)\noptimize(solver, problem, x0=x0)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The BnB algorithm will construct its first upper bound based on the evaluation of x0 in the objective of the problem. Moreover, it is also possible to force indices of the problem variable to zero or non-zero from the beginning of the algorithm. This can be done with","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"idx_zer = [1,2,3]\nidx_nnz = [4,5,6]\nresult = optimize(solver, problem, S0=idx_zer, S1=idx_nnz)\nprintln(result.x[idx_zer])\nprintln(result.x[idx_nnz])","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"One notices that result.x[idx_zer] and result.x[idx_nnz] indeed correspond to zero and non-zero values, respectively.","category":"page"},{"location":"library/path/#Regularization-path","page":"Regularization path","title":"Regularization path","text":"","category":"section"},{"location":"library/path/","page":"Regularization path","title":"Regularization path","text":"Modules = [El0ps]\nPages   = [\"path.jl\"]","category":"page"},{"location":"library/path/#El0ps.Path","page":"Regularization path","title":"El0ps.Path","text":"Path\n\nRegularization path of a Problem, i.e., solutions for different  values of λ.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.PathOptions","page":"Regularization path","title":"El0ps.PathOptions","text":"PathOptions\n\nOptions for a Path. The path is computed over a  logarithmically-spaced grid λ ∈ [λratio_max, λratio_min] * λmax of  λratio_num different values. The value of λmax is computed using  compute_λmax. \n\nArguments\n\nλratio_max::Float64 : Maximum value of λ/λmax.\nλratio_min::Float64 : Minimum value of λ/λmax.\nλratio_num::Int : Number of values of λ in the regularization path.\nmax_support_size::Int : Stop the path fitting when a solution with support \n\nsize max_support_size is recovered.\n\nstop_if_unsolved::Bool : If true, stop the path fitting if the \n\nProblem at some λ is unsolved.\n\ncompute_cv::Bool : If true, compute the cross-validation error over\n\nnb_folds folds for each solution obtained in the Path.\n\nnb_folds::Int : Number of cross-validation folds.\nverbosity::Bool : Whether to displays outputs.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.fit_path-Tuple{AbstractSolver, AbstractDatafit, AbstractPerturbation, Matrix}","page":"Regularization path","title":"El0ps.fit_path","text":"fit_path(\n    solver::AbstractSolver,\n    f::AbstractDatafit,\n    h::AbstractPerturbation,\n    A::Matrix,\n    kwargs...\n)\n\nFit a regularization Path for a Problem. Additional keyword arguments in kwargs are passed to a PathOptions instance.\n\n\n\n\n\n","category":"method"},{"location":"#El0ps.jl","page":"Home","title":"El0ps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An Exact L0-penalized Problem Solver.","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides solution methods to address the problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"min_mathbfx  f(mathbfymathbfAmathbfx) + lambda g(mathbfx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where g(x) = mathbfx_0 + h(x). It aims to fit an input mathbfy through some model of mathbfAx encoded in the loss function f. It also enforces sparsity in the optimizers with the ell_0-norm, which counts the number of non-zero entries in its argument. The function h is a perturbation term required to build-up efficient numerical procedures. In particular, El0ps.jl implements a Branch-and-Bound algorithm that exploits the structure of the problem to achieve competitive performances.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple problem instantiation\nEasy process to define new functions f and h\nBranch-and-Bound algorithm with\nSeveral exploration strategies\nSeveral branching strategies\nTunable parameters\nEfficient bounding solver\nStructure-exploiting acceleration methods\nRoutines to fit regularization paths","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite El0ps.jl, please refer to the following paper (in french):","category":"page"},{"location":"","page":"Home","title":"Home","text":"@inproceedings{guyard2023solveur,\n  title={Un solveur efficace pour la r{\\'e}solution de probl{\\`e}mes parcimonieux avec p{\\'e}nalit{\\'e} L0},\n  author={Guyard, Theo},\n  booktitle={24{\\`e}me {\\'e}dition du congr{\\`e}s annuel de la Soci{\\'e}t{\\'e} Fran{\\c{c}}aise de Recherche Op{\\'e}rationnelle et d'Aide {\\`a} la D{\\'e}cision},\n  year={2023}\n}","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual/quickstart.md\", \"manual/optimize.md\", \"manual/path.md\", \"manual/custom.md\"]","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/problem.md\", \"library/datafits.md\", \"library/penalties.md\", \"library/solvers.md\", \"library/path.md\"]","category":"page"},{"location":"library/datafits/#Datafits","page":"Datafits","title":"Datafits","text":"","category":"section"},{"location":"library/datafits/","page":"Datafits","title":"Datafits","text":"Modules = [El0ps]\nPages   = [\n    \"datafits/core.jl\",\n    \"datafits/leastsquares.jl\",\n    \"datafits/logistic.jl\",\n]","category":"page"},{"location":"library/datafits/#El0ps.LeastSquares","page":"Datafits","title":"El0ps.LeastSquares","text":"LeastSquares <: AbstractDatafit\n\nLeast-squares function f(mathbfx) = tfrac1m mathbfy-mathbfx_2^2, where m = length(y).\n\n\n\n\n\n","category":"type"},{"location":"library/datafits/#El0ps.Logistic","page":"Datafits","title":"El0ps.Logistic","text":"Logistic <: AbstractDatafit\n\nLogistic function f(mathbfx) = tfrac1m sum(log(mathbf1 + exp(- mathbfy odot mathbfx))) where m = length(y), where odot denotes the Hadamard product and where the log and the exp functions are taken component-wisely.\n\n\n\n\n\n","category":"type"}]
}
