var documenterSearchIndex = {"docs":
[{"location":"manual/path/#Regularization-path","page":"Fitting paths","title":"Regularization path","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"In this section, we consider some Problem data for which we want to fit a regularization path, i.e., solving the problem for a range of λ values. For each value, the corresponding problem will be solved with a BnbSolver.","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"using El0ps\nusing Random\nRandom.seed!(42)\n\ny = randn(10)\nf = LeastSquares(y)\nM = 1.\nh = Bigm(M)\nA = randn(10, 30)\n\nsolver = BnbSolver()","category":"page"},{"location":"manual/path/#Fitting-the-path","page":"Fitting paths","title":"Fitting the path","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"The path if fitted using the fit_path function as follows:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"path = fit_path(solver, f, h, A)","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"This operation returns a Path instance with several information:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"λ/λmax: the ratio between the current λ and the value λmax above which the solution to the problem is necessarily the all-zero vector\nConv: whether the solver has converged\nTime: solution time\nFval: value of f(mathbfAx)\nhval: value of g(mathbfx) = mathbfx_0 + h(mathbfx)\nNnz: number of non-zeros in the solution\nCV mean: mean cross validation error on the term f(mathbfAx)\nCV std: standard deviation of the cross validation error on the term f(mathbfAx)","category":"page"},{"location":"manual/path/#Specifying-parameters","page":"Fitting paths","title":"Specifying parameters","text":"","category":"section"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"When fitting the path, the following parameters can be specified:","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"λratio_max: the maximum value of λ/λmax\nλratio_min: the minimum value of λ/λmax\nλratio_num: the number of λ values in the path\nmax_support_size: when a solution x is obtained in the path with norm(x,0) > max_support_size, the fitting is stopped\nstop_if_unsolved: stop the fitting when the problem at some λ has not been solved\ncompute_cv: whether to compute the cross validation error\nnb_folds: number of folds in the cross validation evaluation\nverbosity: toggle displays during the fitting","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"They are passed to the fit_path function as keyword arguments.","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"path = fit_path(solver, f, h, A, max_support_size=5, compute_cv=false)","category":"page"},{"location":"manual/path/","page":"Fitting paths","title":"Fitting paths","text":"More information is given in the documentation of the PathOptions struct which handle the path parameters.","category":"page"},{"location":"manual/quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The package can be installed through Julia's Pkg manager as","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> add \"https://github.com/TheoGuyard/El0ps.jl\"","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The package is still in beta version and is not accessible through Julia's general registry yet. An alpha version will be released soon. To make sure that everything went properly, you can run","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> test El0ps","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The package can then be loaded with ","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using El0ps","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"note: Note\nThe package is tested against Julia 1.7 and 1.8 on Linux architectures.","category":"page"},{"location":"manual/custom/#Loss-and-perturbation-functions","page":"Custom functions","title":"Loss and perturbation functions","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"This package is designed to be flexible regarding the choice of the functions f and h. It provides a simple way to define them.","category":"page"},{"location":"manual/custom/#Default-support","page":"Custom functions","title":"Default support","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The package already implements by default the following functions:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Loss / Perturbation Expression Parameters\nLeast-Squares f(mathbfAmathbfx) = tfrac12mathbfy - mathbfAmathbfx_2^2 Vector mathbfy\nLogistic f(mathbfAmathbfx) = mathbf1^toplog(mathbf1 + exp(-mathbfyodotmathbfAmathbfx)) Vector mathbfy\nBig-M h(mathbfx) = mathbbI(mathbfx_infty leq M) Scalar M  0\nBig-M + ell_1-norm h(mathbfx) = mathbbI(mathbfx_infty leq M) + alphamathbfx_1 Scalars Malpha  0\nBig-M + ell_2-norm h(mathbfx) = mathbbI(mathbfx_infty leq M) + betamathbfx_2^2 Scalars Mbeta  0\nell_1-norm h(mathbfx) = alphamathbfx_1 Scalar alpha  0\nell_2-norm h(mathbfx) = betamathbfx_2^2 Scalar beta  0\nell_1ell_2-norm h(mathbfx) = alphamathbfx_1 + betamathbfx_2^2 Scalars alphabeta  0","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"In the above table, mathbbI(mathcalC) denotes the convex indicator of the constraint mathcalC and odot denotes the Hadamard product. They can be instantiated as follows:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"f = LeastSquares(y)\nf = Logistic(y)\nh = Bigm(M)\nh = BigmL1norm(M, α)\nh = BigmL2norm(M, β)\nh = L1norm(α)\nh = L2norm(β)\nh = L1L2norm(α, β)","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The function f and h respectively derive from the AbstractDatafit and AbstractPerturbation structures.","category":"page"},{"location":"manual/custom/#Defining-new-loss-functions","page":"Custom functions","title":"Defining new loss functions","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"To define new functions f, one must verify the following hypotheses:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"the function is convex, proper and lower-semicontinuous\nthe function is differentiable\nthe function gradient is Lipschitz-continuous","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"If so, then a new function f can be defined as follow.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"struct MyNewF <: AbstractDatafit end","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"For instance, the user can specify how it is pretty-printed with","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Base.show(io::IO, f::MyNewF) = print(io, \"MyNewF\")","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"So that the BnbSolver can run, it is also require to define the following functions:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"dim_input(f::LeastSquares) : the dimension of the function input as an Int\nlipschitz_constant(f::MyNewF) : returns the value of the Lipschitz constant of the gradient of f as a Float64 \nvalue(f::MyNewF, w::Vector) : returns the value of f at w as a Float64 \ngradient(f::MyNewF, w::Vector) : returns the gradient of f at w as a Vector \nconjugate(f::MyNewF, w::Vector) : returns the value of the convex conjugate of f at w as a Float64 ","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Once these functions have been overloaded, the BnbSolver is able to handle losses that are instances of MyNewF on his own.","category":"page"},{"location":"manual/custom/#Defining-new-perturbation-terms","page":"Custom functions","title":"Defining new perturbation terms","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"To define new functions h, one must verify the following hypotheses:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"the function splits\nthe splitting terms are proper, convex and lower-semicontinuous\nthe splitting terms are equals\nthe splitting terms are even\nthe splitting terms are coercive\nthe splitting terms are non-negative and equal zero at zero","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The above hypotheses are verified for norms or for bound constraints, among many others. If they are fulfilled, a new perturbation term can be defined as follow.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"struct MyNewH <: AbstractPerturbation end","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"For instance, the user can specify how it is pretty-printed with","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Base.show(io::IO, H::MyNewH) = print(io, \"MyNewH\")","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"So that the BnbSolver can run, it is also require to define the following functions:","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"value_1d(h::MyNewH, x::Float64): returns the value of a splitting term evaluated at x as a Float64 \nconjugate_1d(h::MyNewH, x::Float64): returns the value of the conjugate function of a splitting term evaluated at x as a Float64 \nprox_1d(h::MyNewH, x::Float64, η::Float64): returns the proximity operator of η times a splitting term evaluated at x as a Float64 ","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Once these functions have been overloaded, the BnbSolver is able to handle perturbation terms that are instances of MyNewH on his own.","category":"page"},{"location":"manual/custom/#Examples","page":"Custom functions","title":"Examples","text":"","category":"section"},{"location":"manual/custom/#Loss-function","page":"Custom functions","title":"Loss function","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The following portion of code shows how to implement a quadratic loss function f(mathbfw) = tfrac12mathbfw^topmathbfQmathbfw + mathbfw^topmathbfy.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"# Definition of the new struct \nstruct QuadLoss <: AbstractDatafit \n    Q::Matrix\n    y::Vector\n    QuadLoss(Q::Matrix, y::Vector) = new(Q, y)\nend\n\n# Definition of the operators\ndim_input(f::QuadLoss) = length(f.y)\nlipschitz_constant(f::QuadLoss) = maximum(svdvals(f.Q))\nvalue(f::QuadLoss, w::Vector) = 0.5 * (w' * f.Q * w) + w' * f.y\ngradient(f::QuadLoss, w::Vector) = f.Q * w + f.y\nconjugate(f::QuadLoss, w::Vector) = inv(Q) * (w - f.y)","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"Note that computations can be saved by computing and storing the value of the Lipschitz constant and of mathbfQ^-1 once for all when initializing the QuadLoss structure.","category":"page"},{"location":"manual/custom/#Perturbation-term","page":"Custom functions","title":"Perturbation term","text":"","category":"section"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"The following portion of code shows how to implement a p-norm perturbation term h(mathbfx) = tfrac1pmathbfx^p_p for some integer p geq 1.","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"# Required for the prox operation\nusing Roots\n\n# Definition of the new struct \nstruct LpNorm <: AbstractPerturbation\n    p::Int\n    q::Int\n    LpNorm(p::Int) = new(p, p/(p-1))\nend\n\n# Definition of the operators\nvalue_1d(h::LpNorm, x::Float64) = abs(x)^(h.p) / h.p\nconjugate_1d(h::LpNorm, x::Float64) = abs(x)^(h.q) / h.q\nprox_1d(h::LpNorm, x::Float64, η::Float64) = sign(x) * find_zero(r -> ηr^(h.p-1) + r - abs(x), 0) ","category":"page"},{"location":"manual/custom/","page":"Custom functions","title":"Custom functions","text":"See the prox-website for more details.","category":"page"},{"location":"library/perturbations/#Penalties","page":"Perturbations","title":"Penalties","text":"","category":"section"},{"location":"library/perturbations/","page":"Perturbations","title":"Perturbations","text":"Modules = [El0ps]\nPages   = [\n    \"perturbations/core.jl\",\n    \"perturbations/bigm.jl\",\n    \"perturbations/bigml1norm.jl\",\n    \"perturbations/bigml2norm.jl\",\n    \"perturbations/l1norm.jl\",\n    \"perturbations/l2norm.jl\",\n    \"perturbations/l1l2norm.jl\",\n]","category":"page"},{"location":"library/perturbations/#El0ps.Bigm","page":"Perturbations","title":"El0ps.Bigm","text":"Bigm <: AbstractPerturbation\n\nConvex indicator of a Big-M constraint abs.(x) .<= h.M, where h.M > 0.\n\nArguments\n\nM::Float64 : Big-M value.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.Bigm-Tuple{Float64}","page":"Perturbations","title":"El0ps.Bigm","text":"Bigm(M::Float64)\n\nBigm constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/perturbations/#El0ps.BigmL1norm","page":"Perturbations","title":"El0ps.BigmL1norm","text":"BigmL1norm <: AbstractPerturbation\n\nBig-M constraint plus L1-norm function  h(x) = h.α * norm(x, 1) + (norm(x, Inf) < h.M ? 0. : Inf), where h.α > 0 and  h.M > 0.\n\nArguments\n\nM::Float64 : Big-M value.\nα::Float64 : L1 regularization strength.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.BigmL1norm-Tuple{Float64, Float64}","page":"Perturbations","title":"El0ps.BigmL1norm","text":"BigmL1norm(M::Float64, α::Float64)\n\nBigmL1norm constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/perturbations/#El0ps.BigmL2norm","page":"Perturbations","title":"El0ps.BigmL2norm","text":"BigmL2norm <: AbstractPerturbation\n\nBig-M constraint plus L2-norm function  h(x) = h.α * norm(x, 2)^2 + (norm(x, Inf) < h.M ? 0. : Inf), where h.α > 0  and h.M > 0.\n\nArguments\n\nM::Float64 : Big-M value.\nα::Float64 : L2 regularization strength.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.BigmL2norm-Tuple{Float64, Float64}","page":"Perturbations","title":"El0ps.BigmL2norm","text":"BigmL2norm(M::Float64, α::Float64)\n\nBigmL2norm constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/perturbations/#El0ps.L1norm","page":"Perturbations","title":"El0ps.L1norm","text":"L1norm <: AbstractPerturbation\n\nL1-norm function h(x) = h.α * norm(x, 1), where h.α > 0.\n\nArguments\n\nα::Float64 : L1 regularization strength.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.L1norm-Tuple{Float64}","page":"Perturbations","title":"El0ps.L1norm","text":"L1norm(α::Float64)\n\nL1norm constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/perturbations/#El0ps.L2norm","page":"Perturbations","title":"El0ps.L2norm","text":"L2norm <: AbstractPerturbation\n\nL2-norm function h(x) = h.α * norm(x, 2)^2, where h.α > 0.\n\nArguments\n\nα::Float64 : L2 regularization strength.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.L2norm-Tuple{Float64}","page":"Perturbations","title":"El0ps.L2norm","text":"L2norm(α::Float64)\n\nL2norm constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/perturbations/#El0ps.L1L2norm","page":"Perturbations","title":"El0ps.L1L2norm","text":"L1L2norm <: AbstractPerturbation\n\nL1L2-norm function h(x) = h.α * norm(x, 1) + h.β * norm(x, 2)^2, where  h.α > 0 and h.β > 0.\n\nArguments\n\nα::Float64 : L1 regularization strength.\nβ::Float64 : L2 regularization strength.\n\n\n\n\n\n","category":"type"},{"location":"library/perturbations/#El0ps.L1L2norm-Tuple{Float64, Float64}","page":"Perturbations","title":"El0ps.L1L2norm","text":"L1L2norm(α::Float64, β::Float64)\n\nL1L2norm constructor.\n\n\n\n\n\n","category":"method"},{"location":"manual/problem/#Creating-problems","page":"Creating problems","title":"Creating problems","text":"","category":"section"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"This package is designed to solve L0-penalized problems. The different components of this type of problems are: the loss function f, the perturbation function h, the feature matrix mathbfA, and the hyperparameter lambda. Here is an example on how a Problem can be instantiated.","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"using El0ps\nusing Random\nRandom.seed!(42)\n\n# Problem data\ny = randn(10)\nf = LeastSquares(y)\nM = 1.\nh = Bigm(M)\nA = randn(10, 30)\nλ = 0.1\n\n# Problem instantiation\nproblem = Problem(f, h, A, λ)","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"Here, the functions f and h are defined via structures provided by default in our package.  The function f must derive from the AbstractDatafit structure and the function h must derive from the AbstractPerturbation structure. The number of rows in A must match the input dimension of f. It columns needs not to be normalized but all-zero columns are not allowed. These latter can be removed safely without modifying the problem solutions and optimal value. Finally, the parameter λ must be strictly positive.","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"When displaying a Problem, λmax is a value of λ above which the solution is always the all-zero vector. It can be computed from the problem data as follows:","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"λmax = compute_λmax(f, h, A)","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"Note that setting λ < λmax does not necessarily ensure to obtain a solution with some non-zero elements. However, we observe that it is almost always the case in practice.","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"The objective value of a Problem can be evaluated at any point x matching the dimensions of A using","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"x = rand(30)\nv = objective(problem, x)","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"If the value of Ax is already known, this evaluation can also be done with","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"w = A * x\nv = objective(problem, x, w)","category":"page"},{"location":"manual/problem/","page":"Creating problems","title":"Creating problems","text":"in order to avoid re-evaluating the product Ax and to save computations.","category":"page"},{"location":"library/solver/#Solvers","page":"Solver","title":"Solvers","text":"","category":"section"},{"location":"library/solver/","page":"Solver","title":"Solver","text":"Modules = [El0ps]\nPages   = [\n    \"solver.jl\",\n]","category":"page"},{"location":"library/solver/#El0ps.BnbNodeStatus","page":"Solver","title":"El0ps.BnbNodeStatus","text":"NodeStatus\n\nStatus of a BnbNode.\n\nOPEN : The node has not been treated yet.\nPRUNED : The node has been pruned\nSOLVED : The node has been treated and not pruned.\nPERFECT : The node has a perfect relaxation.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BnbNodeType","page":"Solver","title":"El0ps.BnbNodeType","text":"NodeType\n\nTyep of a BnbNode.\n\nROOT : Root node.\nZERO : Created by setting an entry to zero. \nONE : Created by setting an entry to non-zero. \n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BnbOptions","page":"Solver","title":"El0ps.BnbOptions","text":"BnbOptions\n\nOptions of a BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BnbOptions-Tuple{}","page":"Solver","title":"El0ps.BnbOptions","text":"BnbOptions(;\n    lb_solver::AbstractBoundingSolver   = CDAS(LOWER_BOUNDING),\n    ub_solver::AbstractBoundingSolver   = CDAS(UPPER_BOUNDING),\n    exploration::ExplorationStrategy    = DFS,\n    depthswitch::Int                    = 10,\n    branching::BranchingStrategy        = LARGEST,\n    maxtime::Float64                    = 60.,\n    maxnode::Int                        = typemax(Int),\n    tolgap::Float64                     = 1e-8,\n    tolint::Float64                     = 1e-8,\n    tolprune::Float64                   = 0.,\n    dualpruning::Bool                   = false,\n    l0screening::Bool                   = false,\n    l1screening::Bool                   = false,\n    verbosity::Bool                     = false,\n    showevery::Int                      = 1,\n    keeptrace::Bool                     = false,\n)\n\nInstantiate a BnbOptions.\n\nKeywords:\n\nlb_solver::AbstractBoundingSolver : Solver for the lower-bounding step.\nub_solver::AbstractBoundingSolver : Solver for the upper-bounding step.\nexploration::ExplorationStrategy : Tree exploration strategy.\ndepthswitch::Int : The depth where the MIXED ExplorationStrategy\n\nis switched. \n\nbranching::BranchingStrategy : Tree branching strategy.\nmaxtime::Float64 : Maximum solution time in seconds.\nmaxnode::Int : Maximum number of nodes.\ntolgap::Float64 : Relative MIP gap tolerance.\ntolint::Float64 : Integer tolerance, i.e., x = 0 when |x| < tolint.\ntolprune::Float64 : Prune a node in the bnb tree when `bnb.ub + \n\ntolprune < node.lb`.\n\ndualpruning::Bool : Toogle the dual-pruning acceleration.\nl0screening::Bool : Toogle the L0-screening acceleration.\nl1screening::Bool : Toogle the L1-screening acceleration.\nverbosity::Bool : Toogle verbosity.\nshowevery::Int : Displays logs every showevery nodes explored.\nkeeptrace::Bool : Whether to fill the BnbTrace or not.\n\n\n\n\n\n","category":"method"},{"location":"library/solver/#El0ps.BnbResult","page":"Solver","title":"El0ps.BnbResult","text":"BnbResult\n\nResult of a BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BnbSolver","page":"Solver","title":"El0ps.BnbSolver","text":"BnbSolver\n\nBranch-and-Bound solver for a Problem.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BnbSolver-Tuple{}","page":"Solver","title":"El0ps.BnbSolver","text":"BnbSolver(; kwargs...)\n\nInstantiate a BnbSolver. Keywords are passed to BnbOptions.\n\n\n\n\n\n","category":"method"},{"location":"library/solver/#El0ps.BnbTrace","page":"Solver","title":"El0ps.BnbTrace","text":"BnbTrace\n\nTrace of a BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.BranchingStrategy","page":"Solver","title":"El0ps.BranchingStrategy","text":"BranchingStrategy\n\nBranching strategy of a BnbSolver.\n\nLARGEST : Select the largest index in absolute value in the relaxation \n\nsolution.\n\nRESIDUAL : Select the largest index in absolute value in the dual residual.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.ExplorationStrategy","page":"Solver","title":"El0ps.ExplorationStrategy","text":"ExplorationStrategy\n\nExploration strategy of a BnbSolver.\n\nBFS : Breadth-First Search\nDFS : Depth-First Search\nMIXED : Mixed exploration strategy where the k-top layers of nodes are \n\nexplored in a DFS fashion and where the below ones are explored in a BFS  fashion. The parameter k is specified in BnbOptions.\n\n\n\n\n\n","category":"type"},{"location":"library/solver/#El0ps.optimize-Tuple{BnbSolver, Problem}","page":"Solver","title":"El0ps.optimize","text":"optimize(\n    solver::BnbSolver,\n    problem::Problem;\n    x0::Union{Vector,Nothing}=nothing,\n    S0::Vector{Int}=Vector{Int}(),\n    S1::Vector{Int}=Vector{Int}(),\n)\n\nOptimize a Problem with a BnbSolver. The argument x0 is used as a warm start. The arguments S0 and S1 can be used to impose zero and non-zero constraints directly in the root node. They must match x0.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"library/problem/","page":"Problem","title":"Problem","text":"Modules = [El0ps]\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/problem/#El0ps.Problem","page":"Problem","title":"El0ps.Problem","text":"Problem\n\nStructure for L0-penalized problems.\n\n\n\n\n\n","category":"type"},{"location":"library/problem/#El0ps.Problem-Tuple{AbstractDatafit, AbstractPerturbation, Matrix, Float64}","page":"Problem","title":"El0ps.Problem","text":"Problem(\n    f::AbstractDatafit,\n    h::AbstractPerturbation,\n    A::Matrix,\n    λ::Float64,\n)\n\nInstantiate a Problem of the form min f(Ax) + λ (norm(x,0) + h(x)).\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.compute_λmax-Tuple{AbstractDatafit, AbstractPerturbation, Matrix}","page":"Problem","title":"El0ps.compute_λmax","text":"compute_λmax(\n    f::AbstractDatafit, \n    h::AbstractPerturbation, \n    A::Matrix, \n    y::Vector\n)\n\nReturn a value of λ such that 0 is a solution of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector, Ax::Vector)\n\nValue of the objective of a Problem when Ax is already computed.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector)\n\nValue of the objective of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#Datafits","page":"Datafits","title":"Datafits","text":"","category":"section"},{"location":"library/datafits/","page":"Datafits","title":"Datafits","text":"Modules = [El0ps]\nPages   = [\n    \"datafits/core.jl\",\n    \"datafits/leastsquares.jl\",\n    \"datafits/logistic.jl\",\n]","category":"page"},{"location":"library/datafits/#El0ps.LeastSquares","page":"Datafits","title":"El0ps.LeastSquares","text":"LeastSquares <: AbstractDatafit\n\nLeast-squares function f(w) = norm(f.y - w, 2)^2 / f.m where  f.m = length(f.y).\n\nAttributes\n\ny::Vector : Target data vector.\nm::Int : Size of y.\n\n\n\n\n\n","category":"type"},{"location":"library/datafits/#El0ps.LeastSquares-Tuple{Vector}","page":"Datafits","title":"El0ps.LeastSquares","text":"LeastSquares(y::Vector)\n\nLeastSquares constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.Logistic","page":"Datafits","title":"El0ps.Logistic","text":"Logistic <: AbstractDatafit\n\nLogistic function f(w) = sum(log.(1.0 .+ exp.(-f.y .* x))) / f.m where  f.m = length(f.y).\n\nAttributes\n\ny::Vector : Target data vector.\nm::Int : Size of y.\n\n\n\n\n\n","category":"type"},{"location":"library/datafits/#El0ps.Logistic-Tuple{Vector}","page":"Datafits","title":"El0ps.Logistic","text":"Logistic(y::Vector)\n\nLogistic constructor.\n\n\n\n\n\n","category":"method"},{"location":"manual/optimize/#Solving-problems","page":"Solving problems","title":"Solving problems","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"In this section, we consider a Problem instance that is to be solved.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"using El0ps\nusing Random\nRandom.seed!(42)\n\ny = randn(10)\nf = LeastSquares(y)\nM = 1.\nh = Bigm(M)\nA = randn(10, 30)\nλ = 0.1 * compute_λmax(f, h, A)\n\nproblem = Problem(f, h, A, λ)","category":"page"},{"location":"manual/optimize/#Running-the-solver","page":"Solving problems","title":"Running the solver","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The problem can be addressed with a BnbSolver that can be instantiated as follows ","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"solver = BnbSolver()","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Then, the optimize function allows to solve the problem.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result = optimize(solver, problem)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The result specifies different statistics about the solving process:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The solution status\nOPTIMAL when convergence is achieved \nTIME_LIMIT when the maximum time allowed is reached\nITERATION_LIMIT when the maximum number of nodes allowed is reached\nThe best objective value obtained\nThe number of non-zero elements in the solution\nThe last gap\nThe overall solution time\nThe number of nodes processed","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The solution can be accessed via","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result.x","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"warning: Warning\nWhen the solution status is not OPTIMAL, then the objective value may not correspond to the optimal value of the problem and the solution returned may not be the optimal one.","category":"page"},{"location":"manual/optimize/#Specifying-parameters","page":"Solving problems","title":"Specifying parameters","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"When creating a BnbSolver, different parameters can be specified. First, there exists parameters to control and limit the execution of the solver:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"exploration : the BnB exploration strategy (BFS, DFS or MIXED)\nbranching : the BnB branching strategy (LARGEST or RESIDUAL)\nmaxtime : the maximum solution time in seconds\nmaxnode : the maximum number of nodes \ntolgap : the targeted MIP duality gap in the BnB\ntolint : the integrality tolerance in the BnB\ntolprune : the tolerance when testing if a node is pruned","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Moreover, the use can toggle different acceleration strategies using the boolean parameters.  All these acceleration do not impact the correctness of the BnB process.","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"dualpruning : allows to detect prunable nodes early\nl0screening : enable the node-screening methodology to avoid uninteresting nodes in the BnB\nl1screening : enable the screening methodology to accelerate the node bounding process","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"Finally, the BnB displays and logs can also be controlled via:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"verbosity : toggle displays while solving the problem\nshowevery : difference in nodes between two consecutive displays\nkeeptrace : return a trace of the exploration in the result","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"They can be passed to the solver as keywords arguments:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"solver = BnbSolver(maxtime=60., verbosity=false)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"More information is given in the documentation of the BnbOptions structure that collects the keywords passed to a BnbSolver.","category":"page"},{"location":"manual/optimize/#Warm-start","page":"Solving problems","title":"Warm start","text":"","category":"section"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"When calling optimize, a warm start can be specified as follows:","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"x0 = rand(30)\noptimize(solver, problem, x0=x0)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"The BnB algorithm will construct its first upper bound based on the evaluation of x0 in the objective of the problem. Moreover, it is also possible to force indices of the problem variable to zero or non-zero from the beginning of the algorithm. This can be done with","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"force_zer = [1,2,3]\nforce_nnz = [4,5,6]\nresult = optimize(solver, problem, S0=force_zer, S1=force_nnz)","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"One notices that","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result.x[force_zer]","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"and","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"result.x[force_nnz]","category":"page"},{"location":"manual/optimize/","page":"Solving problems","title":"Solving problems","text":"indeed correspond to zero and non-zero values, respectively.","category":"page"},{"location":"library/path/#Regularization-path","page":"Path","title":"Regularization path","text":"","category":"section"},{"location":"library/path/","page":"Path","title":"Path","text":"Modules = [El0ps]\nPages   = [\"path.jl\"]","category":"page"},{"location":"library/path/#El0ps.Path","page":"Path","title":"El0ps.Path","text":"Path\n\nRegularization path of a Problem, i.e., solutions for different  values of λ.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.PathOptions","page":"Path","title":"El0ps.PathOptions","text":"PathOptions\n\nOptions for a Path. The path is computed over a  logarithmically-spaced grid λ ∈ [λratio_max, λratio_min] * λmax of  λratio_num different values. The value of λmax is computed using  compute_λmax. \n\nArguments\n\nλratio_max::Float64 : Maximum value of λ/λmax.\nλratio_min::Float64 : Minimum value of λ/λmax.\nλratio_num::Int : Number of values of λ in the regularization path.\nmax_support_size::Int : Stop the path fitting when a solution with support \n\nsize max_support_size is recovered.\n\nstop_if_unsolved::Bool : If true, stop the path fitting if the \n\nProblem at some λ is unsolved.\n\ncompute_cv::Bool : If true, compute the cross-validation error over\n\nnb_folds folds for each solution obtained in the Path.\n\nnb_folds::Int : Number of cross-validation folds.\nverbosity::Bool : Whether to displays outputs.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.fit_path-Tuple{AbstractSolver, AbstractDatafit, AbstractPerturbation, Matrix}","page":"Path","title":"El0ps.fit_path","text":"fit_path(\n    solver::AbstractSolver,\n    f::AbstractDatafit,\n    h::AbstractPerturbation,\n    A::Matrix,\n    kwargs...\n)\n\nFit a regularization Path for a Problem. Additional keyword arguments in kwargs are passed to a PathOptions instance.\n\n\n\n\n\n","category":"method"},{"location":"#El0ps.jl","page":"Home","title":"El0ps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An Exact L0-penalized Problem Solver.","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides solution methods to address problems of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"min_mathbfx  f(mathbfAmathbfx) + lambda g(mathbfx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where g(mathbfx) = mathbfx_0 + h(mathbfx). Such problems aim to minimize a loss function f of some linear model mathbfAx. It also enforces sparsity in the optimizers with the ell_0-norm, which counts the number of non-zero entries in its input. The function h is a perturbation term required to build-up efficient numerical procedures. In particular, this package implements a Branch-and-Bound algorithm that exploits the structure of the problem to achieve competitive performances. It it designed to be robust to dimensionality scaling and flexible with respect to the choice of the functions f and h.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"⚙️ Interfaces\nSimple problem instantiation\nEasy process to define new functions f and h\nPretty-print utilities\n🚀 Solution methods\nBranch-and-Bound algorithm\nSpecialized exploration strategies\nSpecialized branching strategies\nMany tunable parameters\nEfficient bounding solver\nStructure-exploiting acceleration methods\nRobust to dimension-scaling\n📈 Utilities\nRegularization path fitting\nEfficiency through warm-start\nCross-validation computations","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite this package, please refer to the following paper (in french):","category":"page"},{"location":"","page":"Home","title":"Home","text":"@inproceedings{guyard2023solveur,\n  title={Un solveur efficace pour la r{\\'e}solution de probl{\\`e}mes parcimonieux avec p{\\'e}nalit{\\'e} L0},\n  author={Guyard, Theo},\n  booktitle={24{\\`e}me {\\'e}dition du congr{\\`e}s annuel de la Soci{\\'e}t{\\'e} Fran{\\c{c}}aise de Recherche Op{\\'e}rationnelle et d'Aide {\\`a} la D{\\'e}cision},\n  year={2023}\n}","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual/quickstart.md\", \"manual/problem.md\", \"manual/optimize.md\", \"manual/path.md\", \"manual/custom.md\"]","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/problem.md\", \"library/datafits.md\", \"library/perturbations.md\", \"library/solver.md\", \"library/path.md\"]","category":"page"}]
}
