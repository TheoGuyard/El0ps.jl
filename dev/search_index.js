var documenterSearchIndex = {"docs":
[{"location":"library/data/#Data-generation","page":"Data generation","title":"Data generation","text":"","category":"section"},{"location":"library/data/","page":"Data generation","title":"Data generation","text":"Modules = [El0ps]\nPages   = [\"data.jl\"]","category":"page"},{"location":"library/data/#El0ps.synthetic_data_classification-Tuple{Int64, Int64, Int64, Float64, Float64}","page":"Data generation","title":"El0ps.synthetic_data_classification","text":"synthetic_data_classification(\n    k::Int,\n    m::Int,\n    n::Int,\n    ρ::Float64,\n    σ::Float64;\n)\n\nGenerate a synthetic classification instance of a Problem with  y ≈ Bernoulli(p) where y[j] = 1 with probability  p[j] = 1 / (1 + exp(-σ[Ax]_j)) and y[j] = -1 otherwise.\n\nArguments\n\nk::Int : Number of non-zeros in x.\nm::Int : Number of rows in A.\nn::Int : Number of columns in A.\nρ::Float64 : Correlation between the columns in A.\nσ::Float64 : Probability parameter.\n\n\n\n\n\n","category":"method"},{"location":"library/data/#El0ps.synthetic_data_regression-Tuple{Int64, Int64, Int64, Float64, Float64}","page":"Data generation","title":"El0ps.synthetic_data_regression","text":"synthetic_data_regression(\n    k::Int,\n    m::Int,\n    n::Int,\n    ρ::Float64,\n    σ::Float64;\n)\n\nGenerate a synthetic regression instance of a Problem with  y = Ax + ϵ where x is a k-sparse vector.\n\nArguments\n\nk::Int : Number of non-zeros in x.\nm::Int : Number of rows in A.\nn::Int : Number of columns in A.\nρ::Float64 : Correlation between the columns in A.\nσ::Float64 : SNR ratio of ϵ with respect to Ax.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#Datafits","page":"Datafits","title":"Datafits","text":"","category":"section"},{"location":"library/datafits/","page":"Datafits","title":"Datafits","text":"Modules = [El0ps]\nPages   = [\n    \"datafits/core.jl\",\n    \"datafits/leastsquares.jl\",\n    \"datafits/logistic.jl\",\n]","category":"page"},{"location":"library/datafits/#El0ps.AbstractDatafit","page":"Datafits","title":"El0ps.AbstractDatafit","text":"AbstractDatafit\n\nAbstract type for the function F in a Problem.\n\n\n\n\n\n","category":"type"},{"location":"library/datafits/#El0ps.bind_model!-Tuple{AbstractDatafit, Vector, JuMP.Model}","page":"Datafits","title":"El0ps.bind_model!","text":"bind_model!(F::AbstractDatafit, y::Vector, model::JuMP.Model)\n\nFormulate the function F in model. See initialize_model for more  details about the argument model.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.conjugate-Tuple{AbstractDatafit, Vector, Vector}","page":"Datafits","title":"El0ps.conjugate","text":"conjugate(F::AbstractDatafit, y::Vector, w::Vector)\n\nFenchel conjugate of F with respect to its second argument.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.dual_scale!-Tuple{AbstractDatafit, Vector, Vector}","page":"Datafits","title":"El0ps.dual_scale!","text":"dual_scale!(F::AbstractDatafit, y::Vector, u::Vector)\n\nIn-place transforms a vector u into a feasible one for the conjugate of F.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.gradient-Tuple{AbstractDatafit, Vector, Vector}","page":"Datafits","title":"El0ps.gradient","text":"gradient(F::AbstractDatafit, y::Vector, w::Vector)\n\nGradient of F with respect to its second argument.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.lipschitz_constant-Tuple{AbstractDatafit, Vector}","page":"Datafits","title":"El0ps.lipschitz_constant","text":"lipschitz_constant(F::AbstractDatafit, y::Vector)\n\nLischitz constant of the gradient of F with respect to its second argument.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.value-Tuple{AbstractDatafit, Vector, Vector}","page":"Datafits","title":"El0ps.value","text":"value(F::AbstractDatafit, y::Vector, w::Vector)\n\nValue of F.\n\n\n\n\n\n","category":"method"},{"location":"library/datafits/#El0ps.LeastSquares","page":"Datafits","title":"El0ps.LeastSquares","text":"LeastSquares <: AbstractDatafit\n\nLeast-squares function \n\nF(mathbfymathbfw) = tfrac1m mathbfy-mathbfw_2^2\n\nwhere m = length(y).\n\n\n\n\n\n","category":"type"},{"location":"library/datafits/#El0ps.Logistic","page":"Datafits","title":"El0ps.Logistic","text":"Logistic <: AbstractDatafit\n\nLogistic function \n\nF(mathbfymathbfw) = tfrac1m sum(log(mathbf1 + exp(- mathbfy odot mathbfw)))\n\nwhere m = length(y), where odot denotes the Hadamard product and where  the log and the exp functions are taken component-wisely.\n\n\n\n\n\n","category":"type"},{"location":"library/problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"library/problem/","page":"Problem","title":"Problem","text":"Modules = [El0ps]\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/problem/#El0ps.Problem","page":"Problem","title":"El0ps.Problem","text":"Problem\n\nProblem of the form \n\nmin F(mathbfymathbfAx) + lambda (x_0 + G(mathbfx))\n\nwhere mathbfA in mathbfR^m times n,  mathbfy in mathbfR^m and lambda  0.\n\n\n\n\n\n","category":"type"},{"location":"library/problem/#El0ps.compute_λmax-Tuple{AbstractDatafit, AbstractPenalty, Matrix, Vector}","page":"Problem","title":"El0ps.compute_λmax","text":"compute_λmax(F::AbstractDatafit, G::AbstractPenalty, A::Matrix, y::Vector)\n\nReturn a value of λ such that 0 is a solution of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector, Ax::Vector)\n\nReturns the value of the objective of a Problem when Ax is already computed.\n\n\n\n\n\n","category":"method"},{"location":"library/problem/#El0ps.objective-Tuple{Problem, Vector}","page":"Problem","title":"El0ps.objective","text":"objective(problem::Problem, x::Vector)\n\nReturns the value of the objective of a Problem.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#Penalties","page":"Penalties","title":"Penalties","text":"","category":"section"},{"location":"library/penalties/","page":"Penalties","title":"Penalties","text":"Modules = [El0ps]\nPages   = [\n    \"penalties/core.jl\",\n    \"penalties/bigm.jl\",\n]","category":"page"},{"location":"library/penalties/#El0ps.AbstractPenalty","page":"Penalties","title":"El0ps.AbstractPenalty","text":"AbstractPenalty\n\nAbstract type for the function G in a Problem. This function is  supposed to split. All its associated methods are therefore implemented with one-dimensional inputs.\n\n\n\n\n\n","category":"type"},{"location":"library/penalties/#El0ps.bind_model!-Tuple{AbstractPenalty, JuMP.Model}","page":"Penalties","title":"El0ps.bind_model!","text":"bind_model!(G::AbstractPenalty, model::JuMP.Model)\n\nFormulate the function G in model. See initialize_model for more  details about the argument model.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.conjugate-Tuple{AbstractPenalty, Vector}","page":"Penalties","title":"El0ps.conjugate","text":"conjugate(G::AbstractPenalty, v::Vector)\n\nValue of the conjugate of G evaluated with a vector v as input.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.conjugate_1d-Tuple{AbstractPenalty, Float64}","page":"Penalties","title":"El0ps.conjugate_1d","text":"conjugate_1d(G::AbstractPenalty, v::Float64)\n\nValue of the conjugate of G.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.conjugate_vectorized-Tuple{AbstractPenalty, Vector}","page":"Penalties","title":"El0ps.conjugate_vectorized","text":"conjugate_vectorized(G::AbstractPenalty, v::Vector)\n\nCoordinate-wise value of the conjugate of G when evaluated with a vector v  as input.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.dual_scale!-Tuple{AbstractPenalty, Matrix, Vector, Float64}","page":"Penalties","title":"El0ps.dual_scale!","text":"dual_scale!(G::AbstractPenalty, A::Matrix, u::Vector, λ::Float64)\n\nIn-place transforms some vector u into a feasible one for the conjugate of G  when evaluated at A'u. Returns the value of A'u.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.params_to_dict-Tuple{AbstractPenalty}","page":"Penalties","title":"El0ps.params_to_dict","text":"params_to_dict(G::AbstractPenalty)\n\nReturns a dictionary with the parameters name and value of the function G.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.prox-Tuple{AbstractPenalty, Vector, Float64}","page":"Penalties","title":"El0ps.prox","text":"prox(G::AbstractPenalty, v::Vector, η::Float64)\n\nProximal mapping of the function ηG evaluated with a vector v as input.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.prox_1d-Tuple{AbstractPenalty, Float64, Float64}","page":"Penalties","title":"El0ps.prox_1d","text":"prox_1d(G::AbstractPenalty, x::Float64, η::Float64)\n\nProximal mapping of the function ηG.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.value-Tuple{AbstractPenalty, Vector}","page":"Penalties","title":"El0ps.value","text":"value(G::AbstractPenalty, v::Vector)\n\nValue of G evaluated with a vector v as input.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.value_1d-Tuple{AbstractPenalty, Float64}","page":"Penalties","title":"El0ps.value_1d","text":"value_1d(G::AbstractPenalty, x::Float64)\n\nValue of G.\n\n\n\n\n\n","category":"method"},{"location":"library/penalties/#El0ps.Bigm","page":"Penalties","title":"El0ps.Bigm","text":"Bigm <: AbstractPenalty\n\nConvex indicator of a Big-M constraint\n\nG(mathbfx) = mathrmInd(mathbfx_infty leq M)\n\nwhere M > 0.\n\nArguments\n\nM::Float64 : Big-M value.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"library/solvers/","page":"Solvers","title":"Solvers","text":"Modules = [El0ps]\nPages   = [\n    \"solvers/core.jl\",\n    \"solvers/bnb.jl\",\n    \"solvers/direct.jl\",\n]","category":"page"},{"location":"library/solvers/#El0ps.AbstractResult","page":"Solvers","title":"El0ps.AbstractResult","text":"AbstractResult\n\nAbstract type to store results of an AbstractSolver. \n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.AbstractSolver","page":"Solvers","title":"El0ps.AbstractSolver","text":"AbstractSolver\n\nAbstract type for a solver tailored to a Problem.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.optimize-Tuple{AbstractSolver, Problem}","page":"Solvers","title":"El0ps.optimize","text":"optimize(\n    solver::AbstractSolver,\n    problem::Problem;\n    x0::Union{Vector,Nothing}=nothing,\n)\n\nOptimize a Problem with an AbstractSolver. The argument x0  is used as a warm start.  \n\n\n\n\n\n","category":"method"},{"location":"library/solvers/#El0ps.BnbOptions","page":"Solvers","title":"El0ps.BnbOptions","text":"BnbOptions\n\nOptions of a BnbSolver.\n\nArguments\n\nlb_solver::AbstractBoundingSolver : Solver for the lower-bounding step.\nub_solver::AbstractBoundingSolver : Solver for the upper-bounding step.\nexploration::ExplorationStrategy : Tree exploration strategy.\nbranching::BranchingStrategy : Tree branching strategy.\nmaxtime::Float64 : Maximum solution time in seconds.\nmaxnode::Int : Maximum number of nodes.\ntolgap::Float64 : Relative MIP gap tolerance.\ntolint::Float64 : Integer tolerance, i.e., x = 0 when |x| < tolint.\ntolprune::Float64 : Prune a node in the bnb tree when bnb.ub + tolprune < node.lb.\ndualpruning::Bool : Toogle the dual-pruning acceleration.\nl0screening::Bool : Toogle the L0-screening acceleration.\nl1screening::Bool : Toogle the L1-screening acceleration.\nverbosity::Bool : Toogle verbosity.\nshowevery::Int : Displays logs every showevery nodes explored.\nkeeptrace::Bool : Whether to fill the BnbTrace or not.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.BnbResult","page":"Solvers","title":"El0ps.BnbResult","text":"BnbResult\n\nResult of a BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.BnbSolver","page":"Solvers","title":"El0ps.BnbSolver","text":"BnbSolver <: AbstractSolver\n\nBranch-and-Bound algorithm to solve a Problem. Additional keyword  arguments in kwargs are passed to a BnbOptions instance.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.BnbTrace","page":"Solvers","title":"El0ps.BnbTrace","text":"BnbTrace\n\nTrace of a BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.BranchingStrategy","page":"Solvers","title":"El0ps.BranchingStrategy","text":"BranchingStrategy\n\nBranching strategy of a BnbSolver.\n\nLARGEST : Select the largest index in absolute value in the relaxed solution.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.ExplorationStrategy","page":"Solvers","title":"El0ps.ExplorationStrategy","text":"ExplorationStrategy\n\nExploration strategy of a BnbSolver.\n\nBFS : Breadth-First Search\nDFS : Depth-First Search\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.optimize-Tuple{BnbSolver, Problem}","page":"Solvers","title":"El0ps.optimize","text":"optimize(\n    solver::BnbSolver,\n    problem::Problem;\n    x0::Union{Vector,Nothing}=nothing,\n    S0::Vector{Int}=Vector{Int}(),\n    S1::Vector{Int}=Vector{Int}(),\n)\n\nOptimize a Problem with a BnbSolver. The argument x0 is used as a warm start. The arguments S0 and S1 can be used to impose zero and non-zero constraints directly in the root node. They must match x0.\n\n\n\n\n\n","category":"method"},{"location":"library/solvers/#El0ps.DirectResult","page":"Solvers","title":"El0ps.DirectResult","text":"DirectResult <: AbstractResult\n\nResult of a DirectSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.DirectSolver","page":"Solvers","title":"El0ps.DirectSolver","text":"DirectSolver <: AbstractSolver\n\nFormulate a Problem as a Mixed-Integer-Program and solve it using the specified optimizer. \n\nArguments\n\noptimizer : The MOI.AbstractOptimizer of the specified optimizer (example \n\n: GLPK.Optimizer).\n\noptions::Dict : Options name and value to pass to the \n\noptimizer with the method set_optimizer_attribute from  MathOptInterface.\n\n\n\n\n\n","category":"type"},{"location":"library/solvers/#El0ps.initialize_model-Tuple{Problem, DirectSolver, Union{Nothing, Vector}, Vector{Int64}, Vector{Int64}}","page":"Solvers","title":"El0ps.initialize_model","text":"initialize_model(problem::Problem, solver::DirectSolver, x0::Vector)\n\nInitialize the JuMP model \n\nmin Fcost + λ Ωcost\nst  Ax = w\n    x ∈ R^n\n    z ∈ {0,1}^n\n    w ∈ R^m\n    Fcost ∈ R\n    Gcost ∈ R\n\nand set the initial value of x to x0. To complete the model, one has to  construct the epigraph formulations of the functions F and G in the  Problem using bind_model! and the scalar values Fcost and Gcost that represent the epigraph value.\n\n\n\n\n\n","category":"method"},{"location":"library/solvers/#El0ps.optimize-Tuple{DirectSolver, Problem}","page":"Solvers","title":"El0ps.optimize","text":"optimize(\n    solver::DirectSolver,\n    problem::Problem;\n    x0::Union{Vector,Nothing}=nothing,\n)\n\nOptimize a Problem with a DirectSolver. The argument x0 is used as a warm start. The arguments S0 and S1 can be used to impose zero and non-zero constraints directly in the root node. They must match x0.\n\n\n\n\n\n","category":"method"},{"location":"examples/optimize/#Solve-a-problem","page":"Solve a problem","title":"Solve a problem","text":"","category":"section"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"This examples shows how to construct a synthetic instance of a Problem and how to solve it using either a DirectSolver or a BnbSolver.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"First, import all the necessary modules. The SCIP optimizer will be used in the DirectSolver.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"using El0ps\nusing SCIP","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"Then, define some parameters and generate a synthetic instance.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"k, m, n, ρ, s = 5, 10, 30, 0.1, 10.\nx, A, y = synthetic_data_regression(k, m, n, ρ, s)","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"Instantiate a Least-squares data-fidelity function and a Big-M constraint with M=1 as follows.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"F = LeastSquares()\nG = Bigm(1.)","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"Finally, compute a value λmax such that the all-zero vector is a solution of the Problem and set the L0-regularization strength to one tenth of this value.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"λmax = compute_λmax(F, G, A, y)\nλ = 0.1 * λmax","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"Now, we are ready to construct an instance of the Problem.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"problem = Problem(F, G, A, y, λ)","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"First, we use the Branch-and-Bound solver and we enable some acceleration strategies.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"solver = BnbSolver(\n    dualpruning = true, \n    l0screening = true, \n    l1screening = true,\n)\nresult = optimize(solver, problem)\nprintln(result)","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"Second, we use the Direct solver with the SCIP optimizer that is called with some options.","category":"page"},{"location":"examples/optimize/","page":"Solve a problem","title":"Solve a problem","text":"solver = DirectSolver(\n    SCIP.Optimizer, \n    options = Dict(\n        \"display/verblevel\" => 0, \n        \"limits/gap\"        => 1e-4,\n    )\n)\nresult = optimize(solver, problem)\nprintln(result)","category":"page"},{"location":"library/bounding/#Bounding-step","page":"Bounding step","title":"Bounding step","text":"","category":"section"},{"location":"library/bounding/","page":"Bounding step","title":"Bounding step","text":"Modules = [El0ps]\nPages   = [\n    \"bounding/core.jl\",\n    \"bounding/cd.jl\",\n    \"bounding/cdas.jl\",\n    \"bounding/acceleration.jl\",\n]","category":"page"},{"location":"library/bounding/#El0ps.AbstractBoundingSolver","page":"Bounding step","title":"El0ps.AbstractBoundingSolver","text":"AbstractBoundingSolver\n\nSolver for the lower and upper bounding steps in the BnbSolver.\n\n\n\n\n\n","category":"type"},{"location":"library/bounding/#El0ps.CD","page":"Bounding step","title":"El0ps.CD","text":"CD\n\nCoordinate Descent solver for the lower and upper bounding steps in the  BnbSolver.\n\nArguments\n\ntolgap::Float64 : Absolute tolearance on the duality gap.\nmaxiter::Int : Maximum number of itrations.\n\n\n\n\n\n","category":"type"},{"location":"library/bounding/#El0ps.CDAS","page":"Bounding step","title":"El0ps.CDAS","text":"CDAS\n\nCoordinate Descent with Active-Set strategy solver for the lower and upper  bounding steps in the BnbSolver.\n\nArguments\n\nreltol::Float64 : Relative tolearance for lower bouning.\nmaxiter_cd::Int : Maximum number of cooridinate descent updates.\nmaxiter_as::Int : Maximum number of active-set updates.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#Regularization-path","page":"Regularization path","title":"Regularization path","text":"","category":"section"},{"location":"library/path/","page":"Regularization path","title":"Regularization path","text":"Modules = [El0ps]\nPages   = [\"path.jl\"]","category":"page"},{"location":"library/path/#El0ps.Path","page":"Regularization path","title":"El0ps.Path","text":"Path\n\nRegularization path of a Problem, i.e., solutions for different  values of λ.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.PathOptions","page":"Regularization path","title":"El0ps.PathOptions","text":"PathOptions\n\nOptions for a Path. The path is computed over a  logarithmically-spaced grid λ ∈ [λratio_max, λratio_min] * λmax of  λratio_num different values. The value of λmax is computed using  compute_λmax. \n\nArguments\n\nλratio_max::Float64 : Maximum value of λ/λmax.\nλratio_min::Float64 : Minimum value of λ/λmax.\nλratio_num::Int : Number of values of λ in the regularization path.\nmax_support_size::Int : Stop the path fitting when a solution with support \n\nsize max_support_size is recovered.\n\nstop_if_unsolved::Bool : If true, stop the path fitting if the \n\nProblem at some λ is unsolved.\n\ncompute_cv::Bool : If true, compute the cross-validation error over\n\nnb_folds folds for each solution obtained in the Path.\n\nnb_folds::Int : Number of cross-validation folds.\nverbosity::Bool : Whether to displays outputs.\n\n\n\n\n\n","category":"type"},{"location":"library/path/#El0ps.fit_path-Tuple{AbstractSolver, AbstractDatafit, AbstractPenalty, Matrix, Vector}","page":"Regularization path","title":"El0ps.fit_path","text":"fit_path(\n    solver::AbstractSolver,\n    F::AbstractDatafit,\n    G::AbstractPenalty,\n    A::Matrix,\n    y::Vector;\n    kwargs...\n)\n\nFit a regularization Path for a Problem. Additional keyword arguments in kwargs are passed to a PathOptions instance.\n\n\n\n\n\n","category":"method"},{"location":"#El0ps.jl","page":"Home","title":"El0ps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An Exact L0-penalized Problem Solver.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: )","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This packages provides routines to solve L0-penalized problems of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"(mathcalP) quad min_mathbfx  F(mathbfymathbfAmathbfx) + lambda mathbfx_0   textst   mathbfx_infty leq M","category":"page"},{"location":"","page":"Home","title":"Home","text":"that aim to decompose some vector mathbfy in mathbfR^m using the columns of the matrix mathbfA in mathbfR^n times m through some model. The function F ensures the quality of the decomposition while the ell_0-norm enforces sparsity. The parameter lambda  0 allows to perform a trade-off between these two paradigms. The Big-M constraint set with some M  0 allows to construct bounded relaxations of the problem. This problem is NP-hard and can be reformulated as a Mixed-Integer Program (MIP).","category":"page"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides :","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Direct solution method that models (mathcalP) as a MIP and then uses a generic MIP solver (CPLEX, Gurobi, ...).\nA Branch-and-Bound method specialized for the problem (mathcalP) enhanced with acceleration strategies leveraging the sparse structure of the problem.\nUtilities to fit a regularization path for (mathcalP), i.e., to generate multiple solutions by varying the parameter lambda.\nUtilities to generate synthetic instances of (mathcalP).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the direct solution method, you have to install the MIP solver you want to use. For instance, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SCIP","category":"page"},{"location":"","page":"Home","title":"Home","text":"in order to use SCIP to solve the MIP formulation of (mathcalP).","category":"page"},{"location":"#Data-fidelity-functions","page":"Home","title":"Data-fidelity functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The data fidelity function F is handled in a flexible way. Our routines only have to know how to compute its value, its gradient, its conjugate function and how to model it in a MIP. Currently supported data-fidelity functions are :","category":"page"},{"location":"","page":"Home","title":"Home","text":"Least-squares : F(mathbfymathbfw) = tfrac1mmathbfy -mathbfw_2^2\nLogistic : F(mathbfymathbfw) = tfrac1mmathbf1^toplog(mathbf1 + exp(-mathbfy odot mathbfw))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please raise an issue if you want to add others. You can also make a pull request on your own. We recommend to mimic the definition of the LeastSquares function.","category":"page"},{"location":"examples/path/#Fit-a-regularization-path","page":"Fit a regularization path","title":"Fit a regularization path","text":"","category":"section"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"This examples shows how to fit a regularization Path associated to a Problem.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"First, import all the necessary modules.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"using El0ps","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"Then, define some parameters and generate a synthetic instance.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"k, m, n, ρ, s = 5, 10, 30, 0.1, 10.\nx, A, y = synthetic_data_regression(k, m, n, ρ, s)","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"Instantiate a Least-squares data-fidelity function and a Big-M constraint with M=1 as follows.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"F = LeastSquares()\nG = Bigm(1.)","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"Set the solver to use when solving a Problem instance at some value of λ in the regularization Path.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"solver = BnbSolver()","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"Finally, fit the regularization path.","category":"page"},{"location":"examples/path/","page":"Fit a regularization path","title":"Fit a regularization path","text":"path = fit_path(solver, F, G, A, y)\nprintln(path)","category":"page"}]
}
